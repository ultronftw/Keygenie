{
  "id": "1749515988729",
  "timestamp": 1749515988729,
  "filePath": "test_keygenie_bot.py",
  "oldContent": "import pytest\nfrom telegram import Update\nfrom telegram.ext import ContextTypes\nfrom unittest.mock import AsyncMock, MagicMock\nimport keygenie_bot\n\n@pytest.mark.asyncio\nasync def test_start_command():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_photo = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.start(update, context)\n    update.message.reply_photo.assert_called_once()\n    args = update.message.reply_photo.call_args[1]\n    assert \"caption\" in args and \"üëæ Welcome to *KeyGenie* Bot!\" in args[\"caption\"]\n\n@pytest.mark.asyncio\nasync def test_cmds_command():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_markdown = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.cmds(update, context)\n    update.message.reply_markdown.assert_called_once()\n    args = update.message.reply_markdown.call_args[0][0]\n    assert \"/start\" in args and \"/buy\" in args\n\n@pytest.mark.asyncio\nasync def test_help_command():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_markdown = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.help_command(update, context)\n    update.message.reply_markdown.assert_called_once()\n    args = update.message.reply_markdown.call_args[0][0]\n    assert \"üõí *How to Use KeyGenie Bot:*\" in args\n\n@pytest.mark.asyncio\nasync def test_terms_command():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_markdown = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.terms(update, context)\n    update.message.reply_markdown.assert_called_once()\n    args = update.message.reply_markdown.call_args[0][0]\n    assert \"Terms and Conditions\" in args\n\n# Additional tests for /buy flow, refund requests, validation, and notifications would be added here.\n",
  "content": "import pytest\nfrom telegram import Update, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes, ConversationHandler\nfrom unittest.mock import AsyncMock, MagicMock\nimport keygenie_bot\n\n@pytest.mark.asyncio\nasync def test_start_command():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_photo = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.start(update, context)\n    update.message.reply_photo.assert_called_once()\n    args = update.message.reply_photo.call_args[1]\n    assert \"caption\" in args and \"üëæ Welcome to *KeyGenie* Bot!\" in args[\"caption\"]\n\n@pytest.mark.asyncio\nasync def test_cmds_command():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_markdown = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.cmds(update, context)\n    update.message.reply_markdown.assert_called_once()\n    args = update.message.reply_markdown.call_args[0][0]\n    assert \"/start\" in args and \"/buy\" in args\n\n@pytest.mark.asyncio\nasync def test_help_command():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_markdown = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.help_command(update, context)\n    update.message.reply_markdown.assert_called_once()\n    args = update.message.reply_markdown.call_args[0][0]\n    assert \"üõí *How to Use KeyGenie Bot:*\" in args\n\n@pytest.mark.asyncio\nasync def test_terms_command():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_markdown = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.terms(update, context)\n    update.message.reply_markdown.assert_called_once()\n    args = update.message.reply_markdown.call_args[0][0]\n    assert \"Terms and Conditions\" in args\n\n@pytest.mark.asyncio\nasync def test_buy_flow():\n    # Test /buy command start\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_text = AsyncMock()\n    update.effective_user = MagicMock()\n    update.effective_user.id = 12345\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n    context.job_queue = MagicMock()\n    context.job_queue.run_once = AsyncMock()\n\n    state = await keygenie_bot.buy_start(update, context)\n    assert state == keygenie_bot.SELECTING_PRODUCT\n    update.message.reply_text.assert_called_once()\n    args = update.message.reply_text.call_args[1]\n    assert isinstance(args['reply_markup'], InlineKeyboardMarkup)\n    assert \"üõí Please select a product\" in args['text']\n\n    # Test product selection\n    update.callback_query = MagicMock()\n    update.callback_query.data = \"SELECT_Product A\"\n    update.callback_query.from_user = MagicMock()\n    update.callback_query.from_user.id = 12345\n    update.callback_query.answer = AsyncMock()\n    update.callback_query.edit_message_text = AsyncMock()\n    update.callback_query.message = MagicMock()\n    update.callback_query.message.reply_text = AsyncMock()\n\n    state = await keygenie_bot.product_selected(update, context)\n    assert state == keygenie_bot.WAITING_FOR_TXID\n    update.callback_query.answer.assert_called_once()\n    update.callback_query.edit_message_text.assert_called_once()\n\n    # Test back button\n    update.callback_query.data = \"BACK_TO_PRODUCTS\"\n    state = await keygenie_bot.product_selected(update, context)\n    assert state == keygenie_bot.SELECTING_PRODUCT\n\n    # Test cancel button\n    update.callback_query.data = \"CANCEL\"\n    state = await keygenie_bot.product_selected(update, context)\n    assert state == ConversationHandler.END\n\n@pytest.mark.asyncio\nasync def test_timeout():\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n    context.bot = MagicMock()\n    context.bot.send_message = AsyncMock()\n    context.job = MagicMock()\n    context.job.data = 12345\n\n    await keygenie_bot.cancel_purchase_flow(context)\n    context.bot.send_message.assert_called_once()\n    args = context.bot.send_message.call_args[1]\n    assert \"timed out\" in args['text']\n\n@pytest.mark.asyncio\nasync def test_txid_handling():\n    # Test valid TXID submission\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.text = \"test_txid_123\"\n    update.message.reply_text = AsyncMock()\n    update.effective_user = MagicMock()\n    update.effective_user.id = 12345\n    update.effective_user.username = \"testuser\"\n    \n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n    context.bot = MagicMock()\n    context.bot.send_message = AsyncMock()\n    context.user_data = {'selected_product': 'Product A'}\n\n    state = await keygenie_bot.txid_received(update, context)\n    assert state == ConversationHandler.END\n    assert update.message.reply_text.call_count >= 1\n\n    # Test missing product\n    context.user_data = {}\n    state = await keygenie_bot.txid_received(update, context)\n    assert state == ConversationHandler.END\n    update.message.reply_text.assert_called_with(\n        \"‚ùå No product selected. Please use /buy to start the purchase flow.\"\n    )\n\n@pytest.mark.asyncio\nasync def test_error_handling():\n    # Test admin notification failure\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.text = \"test_txid_123\"\n    update.message.reply_text = AsyncMock()\n    update.effective_user = MagicMock()\n    update.effective_user.id = 12345\n    \n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n    context.bot = MagicMock()\n    context.bot.send_message = AsyncMock(side_effect=Exception(\"Test error\"))\n    context.user_data = {'selected_product': 'Product A'}\n\n    state = await keygenie_bot.txid_received(update, context)\n    assert state == ConversationHandler.END\n    # Should see error message to user\n    assert any(\"Failed to notify admin\" in call.args[0] \n              for call in update.message.reply_text.call_args_list)\n\n@pytest.mark.asyncio\nasync def test_random_message_handler():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_text = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.handle_random_message(update, context)\n    update.message.reply_text.assert_called_once()\n    args = update.message.reply_text.call_args[0][0]\n    assert any(response in args for response in keygenie_bot.HUMOROUS_RESPONSES)\n",
  "diff": "@@ -1,7 +1,7 @@\n import pytest\n-from telegram import Update\n-from telegram.ext import ContextTypes\n+from telegram import Update, InlineKeyboardMarkup\n+from telegram.ext import ContextTypes, ConversationHandler\n from unittest.mock import AsyncMock, MagicMock\n import keygenie_bot\n \n @pytest.mark.asyncio\n@@ -51,5 +51,121 @@\n     update.message.reply_markdown.assert_called_once()\n     args = update.message.reply_markdown.call_args[0][0]\n     assert \"Terms and Conditions\" in args\n \n-# Additional tests for /buy flow, refund requests, validation, and notifications would be added here.\n+@pytest.mark.asyncio\n+async def test_buy_flow():\n+    # Test /buy command start\n+    update = MagicMock(spec=Update)\n+    update.message = MagicMock()\n+    update.message.reply_text = AsyncMock()\n+    update.effective_user = MagicMock()\n+    update.effective_user.id = 12345\n+    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n+    context.job_queue = MagicMock()\n+    context.job_queue.run_once = AsyncMock()\n+\n+    state = await keygenie_bot.buy_start(update, context)\n+    assert state == keygenie_bot.SELECTING_PRODUCT\n+    update.message.reply_text.assert_called_once()\n+    args = update.message.reply_text.call_args[1]\n+    assert isinstance(args['reply_markup'], InlineKeyboardMarkup)\n+    assert \"üõí Please select a product\" in args['text']\n+\n+    # Test product selection\n+    update.callback_query = MagicMock()\n+    update.callback_query.data = \"SELECT_Product A\"\n+    update.callback_query.from_user = MagicMock()\n+    update.callback_query.from_user.id = 12345\n+    update.callback_query.answer = AsyncMock()\n+    update.callback_query.edit_message_text = AsyncMock()\n+    update.callback_query.message = MagicMock()\n+    update.callback_query.message.reply_text = AsyncMock()\n+\n+    state = await keygenie_bot.product_selected(update, context)\n+    assert state == keygenie_bot.WAITING_FOR_TXID\n+    update.callback_query.answer.assert_called_once()\n+    update.callback_query.edit_message_text.assert_called_once()\n+\n+    # Test back button\n+    update.callback_query.data = \"BACK_TO_PRODUCTS\"\n+    state = await keygenie_bot.product_selected(update, context)\n+    assert state == keygenie_bot.SELECTING_PRODUCT\n+\n+    # Test cancel button\n+    update.callback_query.data = \"CANCEL\"\n+    state = await keygenie_bot.product_selected(update, context)\n+    assert state == ConversationHandler.END\n+\n+@pytest.mark.asyncio\n+async def test_timeout():\n+    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n+    context.bot = MagicMock()\n+    context.bot.send_message = AsyncMock()\n+    context.job = MagicMock()\n+    context.job.data = 12345\n+\n+    await keygenie_bot.cancel_purchase_flow(context)\n+    context.bot.send_message.assert_called_once()\n+    args = context.bot.send_message.call_args[1]\n+    assert \"timed out\" in args['text']\n+\n+@pytest.mark.asyncio\n+async def test_txid_handling():\n+    # Test valid TXID submission\n+    update = MagicMock(spec=Update)\n+    update.message = MagicMock()\n+    update.message.text = \"test_txid_123\"\n+    update.message.reply_text = AsyncMock()\n+    update.effective_user = MagicMock()\n+    update.effective_user.id = 12345\n+    update.effective_user.username = \"testuser\"\n+    \n+    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n+    context.bot = MagicMock()\n+    context.bot.send_message = AsyncMock()\n+    context.user_data = {'selected_product': 'Product A'}\n+\n+    state = await keygenie_bot.txid_received(update, context)\n+    assert state == ConversationHandler.END\n+    assert update.message.reply_text.call_count >= 1\n+\n+    # Test missing product\n+    context.user_data = {}\n+    state = await keygenie_bot.txid_received(update, context)\n+    assert state == ConversationHandler.END\n+    update.message.reply_text.assert_called_with(\n+        \"‚ùå No product selected. Please use /buy to start the purchase flow.\"\n+    )\n+\n+@pytest.mark.asyncio\n+async def test_error_handling():\n+    # Test admin notification failure\n+    update = MagicMock(spec=Update)\n+    update.message = MagicMock()\n+    update.message.text = \"test_txid_123\"\n+    update.message.reply_text = AsyncMock()\n+    update.effective_user = MagicMock()\n+    update.effective_user.id = 12345\n+    \n+    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n+    context.bot = MagicMock()\n+    context.bot.send_message = AsyncMock(side_effect=Exception(\"Test error\"))\n+    context.user_data = {'selected_product': 'Product A'}\n+\n+    state = await keygenie_bot.txid_received(update, context)\n+    assert state == ConversationHandler.END\n+    # Should see error message to user\n+    assert any(\"Failed to notify admin\" in call.args[0] \n+              for call in update.message.reply_text.call_args_list)\n+\n+@pytest.mark.asyncio\n+async def test_random_message_handler():\n+    update = MagicMock(spec=Update)\n+    update.message = MagicMock()\n+    update.message.reply_text = AsyncMock()\n+    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n+\n+    await keygenie_bot.handle_random_message(update, context)\n+    update.message.reply_text.assert_called_once()\n+    args = update.message.reply_text.call_args[0][0]\n+    assert any(response in args for response in keygenie_bot.HUMOROUS_RESPONSES)\n",
  "description": "File modification",
  "taskId": "1749508150593",
  "revisionNumber": 1
}