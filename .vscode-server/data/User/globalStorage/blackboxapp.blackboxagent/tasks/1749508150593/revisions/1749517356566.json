{
  "id": "1749517356566",
  "timestamp": 1749517356566,
  "filePath": "keygenie_bot.py",
  "oldContent": "import logging\nfrom telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import (\n    ApplicationBuilder,\n    CommandHandler,\n    ContextTypes,\n    ConversationHandler,\n    MessageHandler,\n    CallbackQueryHandler,\n    filters,\n)\nimport config\n\n# Enable logging\nlogging.basicConfig(\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO\n)\nlogger = logging.getLogger(__name__)\n\n# States for ConversationHandler\nSELECTING_PRODUCT, WAITING_FOR_TXID, WAITING_FOR_PROOF, CONFIRMING_PAYMENT = range(4)\n\n# Timer job names\nTIMEOUT_JOB_NAME = \"purchase_timeout_{}\"\n\n# Load configuration from config.py\nBOT_TOKEN = config.BOT_TOKEN\nADMIN_ID = config.ADMIN_ID\nBTC_ADDRESS = config.BTC_ADDRESS\nLTC_ADDRESS = config.LTC_ADDRESS\nUSDT_ADDRESS = config.USDT_ADDRESS\nPRODUCTS = config.PRODUCTS\n\ndef clear_purchase_timeout(context: ContextTypes.DEFAULT_TYPE, user_id: int):\n    \"\"\"Clear the purchase timeout job for a user\"\"\"\n    if context.job_queue is None:\n        return\n    current_jobs = context.job_queue.get_jobs_by_name(TIMEOUT_JOB_NAME.format(user_id))\n    for job in current_jobs:\n        job.schedule_removal()\n\nasync def verify_payment(txid: str, product: str) -> bool:\n    # Placeholder for automatic payment verification logic\n    # Currently, automatic verification is disabled; always return False\n    return False\n\n# Command handlers\n\n# Preset humorous responses for random messages\nHUMOROUS_RESPONSES = [\n    \"üòÑ I'm just a bot, but I love a good joke! Try /cmds to see what I can do.\",\n    \"ü§ñ Beep boop! I don't understand that, but I'm here to help with /buy and more.\",\n    \"üòÇ That sounds funny! But let's stick to keys and payments. Use /cmds for commands.\",\n    \"üòú I'm not great at chit-chat, but I can help you buy keys! Try /buy.\",\n    \"üòé Cool story! Now, how about some keys? Use /cmds to get started.\",\n]\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    logger.info(f\"User {update.effective_user.id} started the bot.\")\n    welcome_message = (\n        \"üëæ Welcome to *KeyGenie* Bot!\\n\"\n        \"Your gateway to secure key purchases.\\n\\n\"\n        \"Use /cmds to see available commands.\"\n    )\n    # Send image with welcome message to grab attention\n    image_path = \"robot_head.jpg\"\n    await update.message.reply_photo(photo=open(image_path, \"rb\"), caption=welcome_message)\n    # No need to delete image later, only show on /start\n\nasync def cmds(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    commands_text = (\n        \"üìú *Available Commands:*\\n\"\n        \"/start ‚Äî Welcome message\\n\"\n        \"/cmds ‚Äî List commands\\n\"\n        \"/buy ‚Äî Start purchase flow\\n\"\n        \"/info ‚Äî User info (optional)\\n\"\n        \"/help ‚Äî How to use the bot\\n\"\n        \"/terms ‚Äî Terms and conditions\\n\"\n        \"/status ‚Äî Check payment status\\n\"\n        \"/contact ‚Äî Contact admin\"\n    )\n    await update.message.reply_markdown(commands_text)\n\nasync def handle_random_message(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    import random\n    response = random.choice(HUMOROUS_RESPONSES)\n    await update.message.reply_text(response)\n\nasync def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    help_text = (\n        \"üõí *How to Use KeyGenie Bot:*\\n\"\n        \"1. Use /buy to start the purchase flow.\\n\"\n        \"2. Select a product from the catalog.\\n\"\n        \"3. View the price and payment addresses.\\n\"\n        \"4. Send your payment and then submit the transaction ID (TXID).\\n\"\n        \"5. An admin will verify your payment and send you the key.\\n\\n\"\n        \"Other commands:\\n\"\n        \"/start - Welcome message\\n\"\n        \"/cmds - List commands\\n\"\n        \"/info - Show your user info\\n\"\n        \"/help - Show this help message\\n\"\n        \"/terms - Show terms and conditions\\n\"\n        \"/status - Check payment status\\n\"\n        \"/contact - Contact admin\\n\"\n        \"/cancel - Cancel current operation\"\n    )\n    await update.message.reply_markdown(help_text)\n\nasync def terms(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    terms_text = (\n        \"üìú *Terms and Conditions:*\\n\"\n        \"1. All sales are final.\\n\"\n        \"2. Payment verification is manual.\\n\"\n        \"3. Please ensure you send the correct amount.\\n\"\n        \"4. Contact admin for any issues.\"\n    )\n    await update.message.reply_markdown(terms_text)\n\nasync def info(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    user = update.effective_user\n    info_text = (\n        f\"üë§ *User Info:*\\n\"\n        f\"Username: @{user.username if user.username else 'N/A'}\\n\"\n        f\"User ID: {user.id}\\n\"\n        f\"First Name: {user.first_name}\\n\"\n        f\"Last Name: {user.last_name if user.last_name else 'N/A'}\"\n    )\n    await update.message.reply_markdown(info_text)\n\n# Purchase flow handlers\n\nasync def show_products(update: Update, context: ContextTypes.DEFAULT_TYPE, edit=False):\n    \"\"\"Show product selection keyboard\"\"\"\n    product_names = list(PRODUCTS.keys())\n    keyboard = []\n    row = []\n    for i, name in enumerate(product_names):\n        row.append(InlineKeyboardButton(name, callback_data=f\"SELECT_{name}\"))\n        if (i + 1) % 2 == 0:\n            keyboard.append(row)\n            row = []\n    if row:\n        keyboard.append(row)\n    # Add control buttons\n    keyboard.append([\n        InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"CANCEL\"),\n    ])\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    text = \"üõí Please select a product to buy:\"\n    \n    if edit and update.callback_query:\n        await update.callback_query.edit_message_text(text=text, reply_markup=reply_markup)\n    else:\n        await update.message.reply_text(text=text, reply_markup=reply_markup)\n\nasync def buy_start(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Start the purchase flow\"\"\"\n    logger.info(f\"User {update.effective_user.id} started /buy command.\")\n    \n    # Clear any existing timeout jobs for this user\n    clear_purchase_timeout(context, update.effective_user.id)\n    \n    # Start new 30-minute timer if job queue is available\n    if context.job_queue is not None:\n        context.job_queue.run_once(\n            cancel_purchase_flow, \n            1800, \n            data=update.effective_user.id,\n            name=TIMEOUT_JOB_NAME.format(update.effective_user.id)\n        )\n    \n    await show_products(update, context)\n    return SELECTING_PRODUCT\n\nasync def cancel_purchase_flow(context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle purchase flow timeout\"\"\"\n    user_id = context.job.data\n    try:\n        await context.bot.send_message(\n            chat_id=user_id,\n            text=\"‚è∞ Purchase flow timed out after 30 minutes. Please start again with /buy if you wish.\"\n        )\n    except Exception as e:\n        logger.error(f\"Failed to send timeout message to user {user_id}: {e}\")\n\nasync def product_selected(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle product selection\"\"\"\n    query = update.callback_query\n    await query.answer()\n    \n    if not query.data:\n        await query.edit_message_text(\"‚ùå Invalid selection. Please try again.\")\n        return ConversationHandler.END\n        \n    action = query.data.split('_')[0] if '_' in query.data else query.data\n    \n    if action == \"CANCEL\":\n        await query.edit_message_text(\"‚ùå Purchase cancelled. Use /buy to start again.\")\n        clear_purchase_timeout(context, query.from_user.id)\n        return ConversationHandler.END\n    \n    if query.data == \"BACK_TO_PRODUCTS\":\n        await show_products(update, context, edit=True)\n        return SELECTING_PRODUCT\n    \n    if query.data == \"PAID\":\n        return await handle_paid_button(update, context)\n        \n    if action != \"SELECT\":\n        await query.edit_message_text(\"‚ùå Invalid selection. Please use /buy to start again.\")\n        return ConversationHandler.END\n        \n    product = query.data.split('_', 1)[1]\n    if product not in PRODUCTS:\n        await query.edit_message_text(\"‚ùå Invalid product selected. Please use /buy to start again.\")\n        return ConversationHandler.END\n\n    logger.info(f\"User {query.from_user.id} selected product: {product}\")\n    context.user_data['selected_product'] = product\n    price = PRODUCTS[product]['price']\n    \n    # Create keyboard with payment options\n    keyboard = [\n        [InlineKeyboardButton(\"‚úÖ I've Paid\", callback_data=\"PAID\")],\n        [InlineKeyboardButton(\"‚¨ÖÔ∏è Back\", callback_data=\"BACK_TO_PRODUCTS\")],\n        [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"CANCEL\")]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    \n    payment_info = (\n        f\"üí∞ Price for {product}: {price}\\n\\n\"\n        f\"Please send payment to one of the following addresses:\\n\"\n        f\"BTC: `{BTC_ADDRESS}`\\n\"\n        f\"LTC: `{LTC_ADDRESS}`\\n\"\n        f\"USDT: `{USDT_ADDRESS}`\\n\\n\"\n        \"After payment, click 'I've Paid' to submit your proof of payment.\"\n    )\n    \n    try:\n        await query.edit_message_text(\n            text=payment_info,\n            reply_markup=reply_markup,\n            parse_mode='MarkdownV2'\n        )\n    except Exception as e:\n        # If MarkdownV2 fails, try without formatting\n        await query.edit_message_text(\n            text=payment_info.replace('`', ''),\n            reply_markup=reply_markup\n        )\n    \n    await query.message.reply_text(\n        \"‚ö†Ô∏è Please make sure to double-check your payment details.\\n\"\n        \"You have 30 minutes to complete the purchase.\"\n    )\n    return WAITING_FOR_TXID\n\nimport httpx\nimport json\nimport os\n\nUSER_DATA_FILE = \"user_data.json\"\n\ndef load_user_data():\n    if not os.path.exists(USER_DATA_FILE):\n        return {}\n    with open(USER_DATA_FILE, \"r\") as f:\n        return json.load(f)\n\ndef save_user_data(data):\n    with open(USER_DATA_FILE, \"w\") as f:\n        json.dump(data, f, indent=2)\n\nasync def deliver_key(user_id: int, product: str, context: ContextTypes.DEFAULT_TYPE):\n    user_data = load_user_data()\n    user_record = user_data.get(str(user_id), {\"purchases\": []})\n    product_key = config.PRODUCTS[product][\"key\"]\n\n    # Send the product key to the user\n    try:\n        await context.bot.send_message(\n            chat_id=user_id,\n            text=f\"üéâ Your purchase of *{product}* is confirmed!\\nHere is your product key:\\n`{product_key}`\",\n            parse_mode=\"Markdown\",\n        )\n        logger.info(f\"Delivered key for {product} to user {user_id}\")\n    except Exception as e:\n        logger.error(f\"Failed to deliver key to user {user_id}: {e}\")\n        return False\n\n    # Update user purchase history\n    user_record[\"purchases\"].append({\"product\": product, \"key\": product_key})\n    user_data[str(user_id)] = user_record\n    save_user_data(user_data)\n    return True\n\nasync def handle_paid_button(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle when user clicks the 'I've Paid' button\"\"\"\n    query = update.callback_query\n    await query.answer()\n    \n    keyboard = [\n        [InlineKeyboardButton(\"üìé Upload Payment Proof\", callback_data=\"UPLOAD_PROOF\")],\n        [InlineKeyboardButton(\"üî¢ Enter TXID\", callback_data=\"ENTER_TXID\")],\n        [InlineKeyboardButton(\"‚¨ÖÔ∏è Back\", callback_data=\"BACK_TO_PAYMENT\")],\n        [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"CANCEL\")]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    \n    await query.edit_message_text(\n        \"Please choose how you want to submit your payment proof:\\n\\n\"\n        \"1. Upload a screenshot of your payment\\n\"\n        \"2. Enter the transaction ID (TXID)\",\n        reply_markup=reply_markup\n    )\n    return WAITING_FOR_PROOF\n\nasync def handle_proof_option(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle proof submission option selection\"\"\"\n    query = update.callback_query\n    await query.answer()\n    \n    if query.data == \"BACK_TO_PAYMENT\":\n        # Go back to payment screen\n        product = context.user_data.get('selected_product')\n        if not product:\n            await query.edit_message_text(\"‚ùå Session expired. Please use /buy to start again.\")\n            return ConversationHandler.END\n        \n        # Recreate payment screen\n        keyboard = [\n            [InlineKeyboardButton(\"‚úÖ I've Paid\", callback_data=\"PAID\")],\n            [InlineKeyboardButton(\"‚¨ÖÔ∏è Back\", callback_data=\"BACK_TO_PRODUCTS\")],\n            [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"CANCEL\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        payment_info = (\n            f\"üí∞ Price for {product}: {PRODUCTS[product]['price']}\\n\\n\"\n            f\"Please send payment to one of the following addresses:\\n\"\n            f\"BTC: `{BTC_ADDRESS}`\\n\"\n            f\"LTC: `{LTC_ADDRESS}`\\n\"\n            f\"USDT: `{USDT_ADDRESS}`\\n\\n\"\n            \"After payment, click 'I've Paid' to submit your proof of payment.\"\n        )\n        \n        try:\n            await query.edit_message_text(\n                text=payment_info,\n                reply_markup=reply_markup,\n                parse_mode='MarkdownV2'\n            )\n        except Exception:\n            await query.edit_message_text(\n                text=payment_info.replace('`', ''),\n                reply_markup=reply_markup\n            )\n        return WAITING_FOR_TXID\n    \n    elif query.data == \"UPLOAD_PROOF\":\n        await query.edit_message_text(\n            \"üì∏ Please send a screenshot or photo of your payment confirmation.\\n\\n\"\n            \"Make sure the following details are clearly visible:\\n\"\n            \"- Transaction amount\\n\"\n            \"- Destination address\\n\"\n            \"- Transaction ID/hash\\n\"\n            \"- Date and time\"\n        )\n        return WAITING_FOR_PROOF\n    \n    elif query.data == \"ENTER_TXID\":\n        await query.edit_message_text(\n            \"üî¢ Please enter the transaction ID (TXID) of your payment.\\n\\n\"\n            \"You can find this in your wallet's transaction history.\"\n        )\n        return WAITING_FOR_PROOF\n    \n    return WAITING_FOR_PROOF\n\nasync def handle_proof_submission(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle proof submission (photo or TXID)\"\"\"\n    product = context.user_data.get('selected_product')\n    if not product:\n        await update.message.reply_text(\"‚ùå Session expired. Please use /buy to start again.\")\n        return ConversationHandler.END\n\n    user = update.effective_user\n    proof_type = \"Photo\" if update.message.photo else \"TXID\"\n    \n    # Get proof content\n    if update.message.photo:\n        # Get the largest photo (best quality)\n        photo = update.message.photo[-1]\n        proof_content = photo.file_id\n        \n        # Forward the photo to admin\n        try:\n            await context.bot.send_photo(\n                chat_id=ADMIN_ID,\n                photo=proof_content,\n                caption=(\n                    f\"üì∏ Payment proof received from @{user.username if user.username else user.id}\\n\"\n                    f\"Product: {product}\\n\"\n                    f\"Price: {PRODUCTS[product]['price']}\\n\\n\"\n                    \"Use /approve <user_id> to approve and send the key\"\n                )\n            )\n        except Exception as e:\n            logger.error(f\"Failed to forward proof to admin: {e}\")\n            await update.message.reply_text(\n                \"‚ö†Ô∏è Failed to submit proof. Please try again or contact support.\"\n            )\n            return ConversationHandler.END\n    else:\n        # Text message (TXID)\n        txid = update.message.text.strip()\n        try:\n            await context.bot.send_message(\n                chat_id=ADMIN_ID,\n                text=(\n                    f\"üî¢ Payment TXID received from @{user.username if user.username else user.id}\\n\"\n                    f\"Product: {product}\\n\"\n                    f\"Price: {PRODUCTS[product]['price']}\\n\"\n                    f\"TXID: `{txid}`\\n\\n\"\n                    \"Use /approve <user_id> to approve and send the key\"\n                ),\n                parse_mode=\"MarkdownV2\"\n            )\n        except Exception as e:\n            logger.error(f\"Failed to notify admin: {e}\")\n            await update.message.reply_text(\n                \"‚ö†Ô∏è Failed to submit TXID. Please try again or contact support.\"\n            )\n            return ConversationHandler.END\n\n    # Create confirmation keyboard\n    keyboard = [\n        [\n            InlineKeyboardButton(\"‚úÖ Yes, wait for approval\", callback_data=\"CONFIRM_WAIT\"),\n            InlineKeyboardButton(\"‚ùå No, cancel\", callback_data=\"CANCEL\")\n        ]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    \n    await update.message.reply_text(\n        f\"üì§ Your payment {proof_type} has been submitted to the admin for verification.\\n\\n\"\n        \"Would you like to wait for approval? The admin will verify your payment and send your key.\",\n        reply_markup=reply_markup\n    )\n    \n    return CONFIRMING_PAYMENT\n\nasync def handle_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle user's confirmation of waiting for approval\"\"\"\n    query = update.callback_query\n    await query.answer()\n    \n    if query.data == \"CONFIRM_WAIT\":\n        await query.edit_message_text(\n            \"‚úÖ Thank you! Your payment proof is being reviewed.\\n\\n\"\n            \"You will receive your key as soon as the payment is verified.\\n\"\n            \"This usually takes 5-10 minutes during business hours.\\n\\n\"\n            \"Use /status to check your payment status.\"\n        )\n    else:  # CANCEL\n        await query.edit_message_text(\n            \"‚ùå Purchase cancelled. Use /buy to start again when you're ready.\"\n        )\n    \n    return ConversationHandler.END\n\nasync def status(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    # Placeholder for payment status checking logic\n    await update.message.reply_text(\n        \"üîç Payment status feature is coming soon. Please check back later.\"\n    )\n\nasync def contact(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    contact_info = (\n        \"üìû *Contact Admin:*\\n\"\n        f\"For support or inquiries, please contact {config.ADMIN_USERNAME}.\"\n    )\n    await update.message.reply_markdown(contact_info)\n\nasync def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    await update.message.reply_text(\n        \"‚ùå Purchase flow cancelled.\", reply_markup=ReplyKeyboardRemove()\n    )\n    return ConversationHandler.END\n\ndef main():\n    # Build application with job queue support\n    application = ApplicationBuilder().token(BOT_TOKEN).build()\n    logger.info(\"Starting bot...\")\n\n    conv_handler = ConversationHandler(\n        entry_points=[CommandHandler('buy', buy_start)],\n        states={\n            SELECTING_PRODUCT: [\n                CallbackQueryHandler(product_selected),\n                CommandHandler('cancel', cancel)\n            ],\n            WAITING_FOR_TXID: [\n                MessageHandler(filters.TEXT & ~filters.COMMAND, txid_received),\n                CallbackQueryHandler(product_selected),  # Handle back/cancel buttons\n                CommandHandler('cancel', cancel)\n            ],\n        },\n        fallbacks=[CommandHandler('cancel', cancel)],\n        per_message=False\n    )\n\n    # Add handlers in specific order\n    application.add_handler(CommandHandler('start', start))\n    application.add_handler(CommandHandler('cmds', cmds))\n    application.add_handler(CommandHandler('help', help_command))\n    application.add_handler(CommandHandler('terms', terms))\n    application.add_handler(CommandHandler('info', info))\n    application.add_handler(CommandHandler('status', status))\n    application.add_handler(CommandHandler('contact', contact))\n    application.add_handler(conv_handler)\n\n    # Add handler for random messages to reply with humor\n    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_random_message))\n\n    logger.info(\"Bot handlers registered, starting polling...\")\n    application.run_polling()\n\nif __name__ == '__main__':\n    main()\n",
  "content": "import logging\nfrom telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import (\n    ApplicationBuilder,\n    CommandHandler,\n    ContextTypes,\n    ConversationHandler,\n    MessageHandler,\n    CallbackQueryHandler,\n    filters,\n)\nimport config\n\n# Enable logging\nlogging.basicConfig(\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO\n)\nlogger = logging.getLogger(__name__)\n\n# States for ConversationHandler\nSELECTING_PRODUCT, WAITING_FOR_TXID, WAITING_FOR_PROOF, CONFIRMING_PAYMENT = range(4)\n\n# Timer job names\nTIMEOUT_JOB_NAME = \"purchase_timeout_{}\"\n\n# Load configuration from config.py\nBOT_TOKEN = config.BOT_TOKEN\nADMIN_ID = config.ADMIN_ID\nBTC_ADDRESS = config.BTC_ADDRESS\nLTC_ADDRESS = config.LTC_ADDRESS\nUSDT_ADDRESS = config.USDT_ADDRESS\nPRODUCTS = config.PRODUCTS\n\ndef clear_purchase_timeout(context: ContextTypes.DEFAULT_TYPE, user_id: int):\n    \"\"\"Clear the purchase timeout job for a user\"\"\"\n    if context.job_queue is None:\n        return\n    current_jobs = context.job_queue.get_jobs_by_name(TIMEOUT_JOB_NAME.format(user_id))\n    for job in current_jobs:\n        job.schedule_removal()\n\nasync def verify_payment(txid: str, product: str) -> bool:\n    # Placeholder for automatic payment verification logic\n    # Currently, automatic verification is disabled; always return False\n    return False\n\n# Command handlers\n\n# Preset humorous responses for random messages\nHUMOROUS_RESPONSES = [\n    \"üòÑ I'm just a bot, but I love a good joke! Try /cmds to see what I can do.\",\n    \"ü§ñ Beep boop! I don't understand that, but I'm here to help with /buy and more.\",\n    \"üòÇ That sounds funny! But let's stick to keys and payments. Use /cmds for commands.\",\n    \"üòú I'm not great at chit-chat, but I can help you buy keys! Try /buy.\",\n    \"üòé Cool story! Now, how about some keys? Use /cmds to get started.\",\n]\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    logger.info(f\"User {update.effective_user.id} started the bot.\")\n    welcome_message = (\n        \"üëæ Welcome to *KeyGenie* Bot!\\n\"\n        \"Your gateway to secure key purchases.\\n\\n\"\n        \"Use /cmds to see available commands.\"\n    )\n    # Send image with welcome message to grab attention\n    image_path = \"robot_head.jpg\"\n    await update.message.reply_photo(photo=open(image_path, \"rb\"), caption=welcome_message)\n    # No need to delete image later, only show on /start\n\nasync def cmds(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    commands_text = (\n        \"üìú *Available Commands:*\\n\"\n        \"/start ‚Äî Welcome message\\n\"\n        \"/cmds ‚Äî List commands\\n\"\n        \"/buy ‚Äî Start purchase flow\\n\"\n        \"/info ‚Äî User info (optional)\\n\"\n        \"/help ‚Äî How to use the bot\\n\"\n        \"/terms ‚Äî Terms and conditions\\n\"\n        \"/status ‚Äî Check payment status\\n\"\n        \"/contact ‚Äî Contact admin\"\n    )\n    await update.message.reply_markdown(commands_text)\n\nasync def handle_random_message(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    import random\n    response = random.choice(HUMOROUS_RESPONSES)\n    await update.message.reply_text(response)\n\nasync def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    help_text = (\n        \"üõí *How to Use KeyGenie Bot:*\\n\"\n        \"1. Use /buy to start the purchase flow.\\n\"\n        \"2. Select a product from the catalog.\\n\"\n        \"3. View the price and payment addresses.\\n\"\n        \"4. Send your payment and then submit the transaction ID (TXID).\\n\"\n        \"5. An admin will verify your payment and send you the key.\\n\\n\"\n        \"Other commands:\\n\"\n        \"/start - Welcome message\\n\"\n        \"/cmds - List commands\\n\"\n        \"/info - Show your user info\\n\"\n        \"/help - Show this help message\\n\"\n        \"/terms - Show terms and conditions\\n\"\n        \"/status - Check payment status\\n\"\n        \"/contact - Contact admin\\n\"\n        \"/cancel - Cancel current operation\"\n    )\n    await update.message.reply_markdown(help_text)\n\nasync def terms(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    terms_text = (\n        \"üìú *Terms and Conditions:*\\n\"\n        \"1. All sales are final.\\n\"\n        \"2. Payment verification is manual.\\n\"\n        \"3. Please ensure you send the correct amount.\\n\"\n        \"4. Contact admin for any issues.\"\n    )\n    await update.message.reply_markdown(terms_text)\n\nasync def info(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    user = update.effective_user\n    info_text = (\n        f\"üë§ *User Info:*\\n\"\n        f\"Username: @{user.username if user.username else 'N/A'}\\n\"\n        f\"User ID: {user.id}\\n\"\n        f\"First Name: {user.first_name}\\n\"\n        f\"Last Name: {user.last_name if user.last_name else 'N/A'}\"\n    )\n    await update.message.reply_markdown(info_text)\n\n# Purchase flow handlers\n\nasync def show_products(update: Update, context: ContextTypes.DEFAULT_TYPE, edit=False):\n    \"\"\"Show product selection keyboard\"\"\"\n    product_names = list(PRODUCTS.keys())\n    keyboard = []\n    row = []\n    for i, name in enumerate(product_names):\n        row.append(InlineKeyboardButton(name, callback_data=f\"SELECT_{name}\"))\n        if (i + 1) % 2 == 0:\n            keyboard.append(row)\n            row = []\n    if row:\n        keyboard.append(row)\n    # Add control buttons\n    keyboard.append([\n        InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"CANCEL\"),\n    ])\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    text = \"üõí Please select a product to buy:\"\n    \n    if edit and update.callback_query:\n        await update.callback_query.edit_message_text(text=text, reply_markup=reply_markup)\n    else:\n        await update.message.reply_text(text=text, reply_markup=reply_markup)\n\nasync def buy_start(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Start the purchase flow\"\"\"\n    logger.info(f\"User {update.effective_user.id} started /buy command.\")\n    \n    # Clear any existing timeout jobs for this user\n    clear_purchase_timeout(context, update.effective_user.id)\n    \n    # Start new 30-minute timer if job queue is available\n    if context.job_queue is not None:\n        context.job_queue.run_once(\n            cancel_purchase_flow, \n            1800, \n            data=update.effective_user.id,\n            name=TIMEOUT_JOB_NAME.format(update.effective_user.id)\n        )\n    \n    await show_products(update, context)\n    return SELECTING_PRODUCT\n\nasync def cancel_purchase_flow(context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle purchase flow timeout\"\"\"\n    user_id = context.job.data\n    try:\n        await context.bot.send_message(\n            chat_id=user_id,\n            text=\"‚è∞ Purchase flow timed out after 30 minutes. Please start again with /buy if you wish.\"\n        )\n    except Exception as e:\n        logger.error(f\"Failed to send timeout message to user {user_id}: {e}\")\n\nasync def product_selected(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle product selection\"\"\"\n    query = update.callback_query\n    await query.answer()\n    \n    if not query.data:\n        await query.edit_message_text(\"‚ùå Invalid selection. Please try again.\")\n        return ConversationHandler.END\n        \n    action = query.data.split('_')[0] if '_' in query.data else query.data\n    \n    if action == \"CANCEL\":\n        await query.edit_message_text(\"‚ùå Purchase cancelled. Use /buy to start again.\")\n        clear_purchase_timeout(context, query.from_user.id)\n        return ConversationHandler.END\n    \n    if query.data == \"BACK_TO_PRODUCTS\":\n        await show_products(update, context, edit=True)\n        return SELECTING_PRODUCT\n    \n    if query.data == \"PAID\":\n        return await handle_paid_button(update, context)\n        \n    if action != \"SELECT\":\n        await query.edit_message_text(\"‚ùå Invalid selection. Please use /buy to start again.\")\n        return ConversationHandler.END\n        \n    product = query.data.split('_', 1)[1]\n    if product not in PRODUCTS:\n        await query.edit_message_text(\"‚ùå Invalid product selected. Please use /buy to start again.\")\n        return ConversationHandler.END\n\n    logger.info(f\"User {query.from_user.id} selected product: {product}\")\n    context.user_data['selected_product'] = product\n    price = PRODUCTS[product]['price']\n    \n    # Create keyboard with payment options\n    keyboard = [\n        [InlineKeyboardButton(\"‚úÖ I've Paid\", callback_data=\"PAID\")],\n        [InlineKeyboardButton(\"‚¨ÖÔ∏è Back\", callback_data=\"BACK_TO_PRODUCTS\")],\n        [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"CANCEL\")]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    \n    payment_info = (\n        f\"üí∞ Price for {product}: {price}\\n\\n\"\n        f\"Please send payment to one of the following addresses:\\n\"\n        f\"BTC: `{BTC_ADDRESS}`\\n\"\n        f\"LTC: `{LTC_ADDRESS}`\\n\"\n        f\"USDT: `{USDT_ADDRESS}`\\n\\n\"\n        \"After payment, click 'I've Paid' to submit your proof of payment.\"\n    )\n    \n    try:\n        await query.edit_message_text(\n            text=payment_info,\n            reply_markup=reply_markup,\n            parse_mode='MarkdownV2'\n        )\n    except Exception as e:\n        # If MarkdownV2 fails, try without formatting\n        await query.edit_message_text(\n            text=payment_info.replace('`', ''),\n            reply_markup=reply_markup\n        )\n    \n    await query.message.reply_text(\n        \"‚ö†Ô∏è Please make sure to double-check your payment details.\\n\"\n        \"You have 30 minutes to complete the purchase.\"\n    )\n    return WAITING_FOR_TXID\n\nimport httpx\nimport json\nimport os\n\nUSER_DATA_FILE = \"user_data.json\"\n\ndef load_user_data():\n    if not os.path.exists(USER_DATA_FILE):\n        return {}\n    with open(USER_DATA_FILE, \"r\") as f:\n        return json.load(f)\n\ndef save_user_data(data):\n    with open(USER_DATA_FILE, \"w\") as f:\n        json.dump(data, f, indent=2)\n\nasync def deliver_key(user_id: int, product: str, context: ContextTypes.DEFAULT_TYPE):\n    user_data = load_user_data()\n    user_record = user_data.get(str(user_id), {\"purchases\": []})\n    product_key = config.PRODUCTS[product][\"key\"]\n\n    # Send the product key to the user\n    try:\n        await context.bot.send_message(\n            chat_id=user_id,\n            text=f\"üéâ Your purchase of *{product}* is confirmed!\\nHere is your product key:\\n`{product_key}`\",\n            parse_mode=\"Markdown\",\n        )\n        logger.info(f\"Delivered key for {product} to user {user_id}\")\n    except Exception as e:\n        logger.error(f\"Failed to deliver key to user {user_id}: {e}\")\n        return False\n\n    # Update user purchase history\n    user_record[\"purchases\"].append({\"product\": product, \"key\": product_key})\n    user_data[str(user_id)] = user_record\n    save_user_data(user_data)\n    return True\n\nasync def handle_paid_button(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle when user clicks the 'I've Paid' button\"\"\"\n    query = update.callback_query\n    await query.answer()\n    \n    keyboard = [\n        [InlineKeyboardButton(\"üìé Upload Payment Proof\", callback_data=\"UPLOAD_PROOF\")],\n        [InlineKeyboardButton(\"üî¢ Enter TXID\", callback_data=\"ENTER_TXID\")],\n        [InlineKeyboardButton(\"‚¨ÖÔ∏è Back\", callback_data=\"BACK_TO_PAYMENT\")],\n        [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"CANCEL\")]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    \n    await query.edit_message_text(\n        \"Please choose how you want to submit your payment proof:\\n\\n\"\n        \"1. Upload a screenshot of your payment\\n\"\n        \"2. Enter the transaction ID (TXID)\",\n        reply_markup=reply_markup\n    )\n    return WAITING_FOR_PROOF\n\nasync def handle_proof_option(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle proof submission option selection\"\"\"\n    query = update.callback_query\n    await query.answer()\n    \n    if query.data == \"BACK_TO_PAYMENT\":\n        # Go back to payment screen\n        product = context.user_data.get('selected_product')\n        if not product:\n            await query.edit_message_text(\"‚ùå Session expired. Please use /buy to start again.\")\n            return ConversationHandler.END\n        \n        # Recreate payment screen\n        keyboard = [\n            [InlineKeyboardButton(\"‚úÖ I've Paid\", callback_data=\"PAID\")],\n            [InlineKeyboardButton(\"‚¨ÖÔ∏è Back\", callback_data=\"BACK_TO_PRODUCTS\")],\n            [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"CANCEL\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        payment_info = (\n            f\"üí∞ Price for {product}: {PRODUCTS[product]['price']}\\n\\n\"\n            f\"Please send payment to one of the following addresses:\\n\"\n            f\"BTC: `{BTC_ADDRESS}`\\n\"\n            f\"LTC: `{LTC_ADDRESS}`\\n\"\n            f\"USDT: `{USDT_ADDRESS}`\\n\\n\"\n            \"After payment, click 'I've Paid' to submit your proof of payment.\"\n        )\n        \n        try:\n            await query.edit_message_text(\n                text=payment_info,\n                reply_markup=reply_markup,\n                parse_mode='MarkdownV2'\n            )\n        except Exception:\n            await query.edit_message_text(\n                text=payment_info.replace('`', ''),\n                reply_markup=reply_markup\n            )\n        return WAITING_FOR_TXID\n    \n    elif query.data == \"UPLOAD_PROOF\":\n        await query.edit_message_text(\n            \"üì∏ Please send a screenshot or photo of your payment confirmation.\\n\\n\"\n            \"Make sure the following details are clearly visible:\\n\"\n            \"- Transaction amount\\n\"\n            \"- Destination address\\n\"\n            \"- Transaction ID/hash\\n\"\n            \"- Date and time\"\n        )\n        return WAITING_FOR_PROOF\n    \n    elif query.data == \"ENTER_TXID\":\n        await query.edit_message_text(\n            \"üî¢ Please enter the transaction ID (TXID) of your payment.\\n\\n\"\n            \"You can find this in your wallet's transaction history.\"\n        )\n        return WAITING_FOR_PROOF\n    \n    return WAITING_FOR_PROOF\n\nasync def handle_proof_submission(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle proof submission (photo or TXID)\"\"\"\n    product = context.user_data.get('selected_product')\n    if not product:\n        await update.message.reply_text(\"‚ùå Session expired. Please use /buy to start again.\")\n        return ConversationHandler.END\n\n    user = update.effective_user\n    proof_type = \"Photo\" if update.message.photo else \"TXID\"\n    \n    # Get proof content\n    if update.message.photo:\n        # Get the largest photo (best quality)\n        photo = update.message.photo[-1]\n        proof_content = photo.file_id\n        \n        # Forward the photo to admin\n        try:\n            await context.bot.send_photo(\n                chat_id=ADMIN_ID,\n                photo=proof_content,\n                caption=(\n                    f\"üì∏ Payment proof received from @{user.username if user.username else user.id}\\n\"\n                    f\"Product: {product}\\n\"\n                    f\"Price: {PRODUCTS[product]['price']}\\n\\n\"\n                    \"Use /approve <user_id> to approve and send the key\"\n                )\n            )\n        except Exception as e:\n            logger.error(f\"Failed to forward proof to admin: {e}\")\n            await update.message.reply_text(\n                \"‚ö†Ô∏è Failed to submit proof. Please try again or contact support.\"\n            )\n            return ConversationHandler.END\n    else:\n        # Text message (TXID)\n        txid = update.message.text.strip()\n        try:\n            await context.bot.send_message(\n                chat_id=ADMIN_ID,\n                text=(\n                    f\"üî¢ Payment TXID received from @{user.username if user.username else user.id}\\n\"\n                    f\"Product: {product}\\n\"\n                    f\"Price: {PRODUCTS[product]['price']}\\n\"\n                    f\"TXID: `{txid}`\\n\\n\"\n                    \"Use /approve <user_id> to approve and send the key\"\n                ),\n                parse_mode=\"MarkdownV2\"\n            )\n        except Exception as e:\n            logger.error(f\"Failed to notify admin: {e}\")\n            await update.message.reply_text(\n                \"‚ö†Ô∏è Failed to submit TXID. Please try again or contact support.\"\n            )\n            return ConversationHandler.END\n\n    # Create confirmation keyboard\n    keyboard = [\n        [\n            InlineKeyboardButton(\"‚úÖ Yes, wait for approval\", callback_data=\"CONFIRM_WAIT\"),\n            InlineKeyboardButton(\"‚ùå No, cancel\", callback_data=\"CANCEL\")\n        ]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    \n    await update.message.reply_text(\n        f\"üì§ Your payment {proof_type} has been submitted to the admin for verification.\\n\\n\"\n        \"Would you like to wait for approval? The admin will verify your payment and send your key.\",\n        reply_markup=reply_markup\n    )\n    \n    return CONFIRMING_PAYMENT\n\nasync def handle_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle user's confirmation of waiting for approval\"\"\"\n    query = update.callback_query\n    await query.answer()\n    \n    if query.data == \"CONFIRM_WAIT\":\n        await query.edit_message_text(\n            \"‚úÖ Thank you! Your payment proof is being reviewed.\\n\\n\"\n            \"You will receive your key as soon as the payment is verified.\\n\"\n            \"This usually takes 5-10 minutes during business hours.\\n\\n\"\n            \"Use /status to check your payment status.\"\n        )\n    else:  # CANCEL\n        await query.edit_message_text(\n            \"‚ùå Purchase cancelled. Use /buy to start again when you're ready.\"\n        )\n    \n    return ConversationHandler.END\n\nasync def status(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    # Placeholder for payment status checking logic\n    await update.message.reply_text(\n        \"üîç Payment status feature is coming soon. Please check back later.\"\n    )\n\nasync def contact(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    contact_info = (\n        \"üìû *Contact Admin:*\\n\"\n        f\"For support or inquiries, please contact {config.ADMIN_USERNAME}.\"\n    )\n    await update.message.reply_markdown(contact_info)\n\nasync def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    await update.message.reply_text(\n        \"‚ùå Purchase flow cancelled.\", reply_markup=ReplyKeyboardRemove()\n    )\n    return ConversationHandler.END\n\ndef main():\n    # Build application with job queue support\n    application = ApplicationBuilder().token(BOT_TOKEN).build()\n    logger.info(\"Starting bot...\")\n\n    conv_handler = ConversationHandler(\n        entry_points=[CommandHandler('buy', buy_start)],\n        states={\n            SELECTING_PRODUCT: [\n                CallbackQueryHandler(product_selected),\n                CommandHandler('cancel', cancel)\n            ],\n            WAITING_FOR_TXID: [\n                CallbackQueryHandler(product_selected),  # Handle paid/back/cancel buttons\n                CommandHandler('cancel', cancel)\n            ],\n            WAITING_FOR_PROOF: [\n                CallbackQueryHandler(handle_proof_option),  # Handle proof option buttons\n                MessageHandler(filters.PHOTO | (filters.TEXT & ~filters.COMMAND), handle_proof_submission),\n                CommandHandler('cancel', cancel)\n            ],\n            CONFIRMING_PAYMENT: [\n                CallbackQueryHandler(handle_confirmation),  # Handle confirmation buttons\n                CommandHandler('cancel', cancel)\n            ],\n        },\n        fallbacks=[CommandHandler('cancel', cancel)],\n        per_message=False\n    )\n\n    # Add handlers in specific order\n    application.add_handler(CommandHandler('start', start))\n    application.add_handler(CommandHandler('cmds', cmds))\n    application.add_handler(CommandHandler('help', help_command))\n    application.add_handler(CommandHandler('terms', terms))\n    application.add_handler(CommandHandler('info', info))\n    application.add_handler(CommandHandler('status', status))\n    application.add_handler(CommandHandler('contact', contact))\n    application.add_handler(conv_handler)\n\n    # Add handler for random messages to reply with humor\n    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_random_message))\n\n    logger.info(\"Bot handlers registered, starting polling...\")\n    application.run_polling()\n\nif __name__ == '__main__':\n    main()\n",
  "diff": "@@ -500,12 +500,20 @@\n                 CallbackQueryHandler(product_selected),\n                 CommandHandler('cancel', cancel)\n             ],\n             WAITING_FOR_TXID: [\n-                MessageHandler(filters.TEXT & ~filters.COMMAND, txid_received),\n-                CallbackQueryHandler(product_selected),  # Handle back/cancel buttons\n+                CallbackQueryHandler(product_selected),  # Handle paid/back/cancel buttons\n                 CommandHandler('cancel', cancel)\n             ],\n+            WAITING_FOR_PROOF: [\n+                CallbackQueryHandler(handle_proof_option),  # Handle proof option buttons\n+                MessageHandler(filters.PHOTO | (filters.TEXT & ~filters.COMMAND), handle_proof_submission),\n+                CommandHandler('cancel', cancel)\n+            ],\n+            CONFIRMING_PAYMENT: [\n+                CallbackQueryHandler(handle_confirmation),  # Handle confirmation buttons\n+                CommandHandler('cancel', cancel)\n+            ],\n         },\n         fallbacks=[CommandHandler('cancel', cancel)],\n         per_message=False\n     )\n",
  "description": "File modification",
  "taskId": "1749508150593",
  "revisionNumber": 1
}