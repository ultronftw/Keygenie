{
  "id": "1749516185533",
  "timestamp": 1749516185533,
  "filePath": "test_keygenie_bot.py",
  "oldContent": "import pytest\nfrom telegram import Update, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes, ConversationHandler\nfrom unittest.mock import AsyncMock, MagicMock\nimport keygenie_bot\n\n@pytest.mark.asyncio\nasync def test_start_command():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_photo = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.start(update, context)\n    update.message.reply_photo.assert_called_once()\n    args = update.message.reply_photo.call_args[1]\n    assert \"caption\" in args and \"üëæ Welcome to *KeyGenie* Bot!\" in args[\"caption\"]\n\n@pytest.mark.asyncio\nasync def test_cmds_command():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_markdown = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.cmds(update, context)\n    update.message.reply_markdown.assert_called_once()\n    args = update.message.reply_markdown.call_args[0][0]\n    assert \"/start\" in args and \"/buy\" in args\n\n@pytest.mark.asyncio\nasync def test_help_command():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_markdown = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.help_command(update, context)\n    update.message.reply_markdown.assert_called_once()\n    args = update.message.reply_markdown.call_args[0][0]\n    assert \"üõí *How to Use KeyGenie Bot:*\" in args\n\n@pytest.mark.asyncio\nasync def test_terms_command():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_markdown = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.terms(update, context)\n    update.message.reply_markdown.assert_called_once()\n    args = update.message.reply_markdown.call_args[0][0]\n    assert \"Terms and Conditions\" in args\n\n@pytest.mark.asyncio\nasync def test_buy_flow():\n    # Test /buy command start\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_text = AsyncMock()\n    update.effective_user = MagicMock()\n    update.effective_user.id = 12345\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n    context.job_queue = MagicMock()\n    context.job_queue.run_once = MagicMock()  # Changed to MagicMock to avoid async warning\n    context.job_queue.get_jobs_by_name = MagicMock(return_value=[])\n\n    state = await keygenie_bot.buy_start(update, context)\n    assert state == keygenie_bot.SELECTING_PRODUCT\n    update.message.reply_text.assert_called_once()\n    args = update.message.reply_text.call_args[1]\n    assert isinstance(args['reply_markup'], InlineKeyboardMarkup)\n    assert \"üõí Please select a product\" in args['text']\n\n    # Test product selection with valid product\n    update.callback_query = MagicMock()\n    update.callback_query.data = \"SELECT_Product A\"\n    update.callback_query.from_user = MagicMock()\n    update.callback_query.from_user.id = 12345\n    update.callback_query.answer = AsyncMock()\n    update.callback_query.edit_message_text = AsyncMock()\n    update.callback_query.message = MagicMock()\n    update.callback_query.message.reply_text = AsyncMock()\n    context.user_data = {}\n\n    state = await keygenie_bot.product_selected(update, context)\n    assert state == keygenie_bot.WAITING_FOR_TXID\n    update.callback_query.answer.assert_called_once()\n    update.callback_query.edit_message_text.assert_called_once()\n\n    # Test cancel button\n    update.callback_query.data = \"CANCEL\"\n    state = await keygenie_bot.product_selected(update, context)\n    assert state == ConversationHandler.END\n\n    # Test back button - this should show products again\n    update.callback_query.data = \"BACK_TO_PRODUCTS\"\n    update.callback_query.edit_message_text.reset_mock()\n    state = await keygenie_bot.product_selected(update, context)\n    assert state == keygenie_bot.SELECTING_PRODUCT\n    update.callback_query.edit_message_text.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_timeout():\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n    context.bot = MagicMock()\n    context.bot.send_message = AsyncMock()\n    context.job = MagicMock()\n    context.job.data = 12345\n\n    await keygenie_bot.cancel_purchase_flow(context)\n    context.bot.send_message.assert_called_once()\n    args = context.bot.send_message.call_args[1]\n    assert \"timed out\" in args['text']\n\n@pytest.mark.asyncio\nasync def test_txid_handling():\n    # Test valid TXID submission\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.text = \"test_txid_123\"\n    update.message.reply_text = AsyncMock()\n    update.effective_user = MagicMock()\n    update.effective_user.id = 12345\n    update.effective_user.username = \"testuser\"\n    \n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n    context.bot = MagicMock()\n    context.bot.send_message = AsyncMock()\n    context.user_data = {'selected_product': 'Product A'}\n\n    state = await keygenie_bot.txid_received(update, context)\n    assert state == ConversationHandler.END\n    assert update.message.reply_text.call_count >= 1\n\n    # Test missing product\n    context.user_data = {}\n    state = await keygenie_bot.txid_received(update, context)\n    assert state == ConversationHandler.END\n    update.message.reply_text.assert_called_with(\n        \"‚ùå No product selected. Please use /buy to start the purchase flow.\"\n    )\n\n@pytest.mark.asyncio\nasync def test_error_handling():\n    # Test admin notification failure\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.text = \"test_txid_123\"\n    update.message.reply_text = AsyncMock()\n    update.effective_user = MagicMock()\n    update.effective_user.id = 12345\n    \n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n    context.bot = MagicMock()\n    context.bot.send_message = AsyncMock(side_effect=Exception(\"Test error\"))\n    context.user_data = {'selected_product': 'Product A'}\n\n    state = await keygenie_bot.txid_received(update, context)\n    assert state == ConversationHandler.END\n    # Should see error message to user\n    assert any(\"Failed to notify admin\" in call.args[0] \n              for call in update.message.reply_text.call_args_list)\n\n@pytest.mark.asyncio\nasync def test_random_message_handler():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_text = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.handle_random_message(update, context)\n    update.message.reply_text.assert_called_once()\n    args = update.message.reply_text.call_args[0][0]\n    assert any(response in args for response in keygenie_bot.HUMOROUS_RESPONSES)\n",
  "content": "import pytest\nfrom telegram import Update, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes, ConversationHandler\nfrom unittest.mock import AsyncMock, MagicMock\nimport keygenie_bot\n\n@pytest.mark.asyncio\nasync def test_start_command():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_photo = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.start(update, context)\n    update.message.reply_photo.assert_called_once()\n    args = update.message.reply_photo.call_args[1]\n    assert \"caption\" in args and \"üëæ Welcome to *KeyGenie* Bot!\" in args[\"caption\"]\n\n@pytest.mark.asyncio\nasync def test_cmds_command():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_markdown = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.cmds(update, context)\n    update.message.reply_markdown.assert_called_once()\n    args = update.message.reply_markdown.call_args[0][0]\n    assert \"/start\" in args and \"/buy\" in args\n\n@pytest.mark.asyncio\nasync def test_help_command():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_markdown = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.help_command(update, context)\n    update.message.reply_markdown.assert_called_once()\n    args = update.message.reply_markdown.call_args[0][0]\n    assert \"üõí *How to Use KeyGenie Bot:*\" in args\n\n@pytest.mark.asyncio\nasync def test_terms_command():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_markdown = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.terms(update, context)\n    update.message.reply_markdown.assert_called_once()\n    args = update.message.reply_markdown.call_args[0][0]\n    assert \"Terms and Conditions\" in args\n\n@pytest.mark.asyncio\nasync def test_buy_flow():\n    # Test /buy command start\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_text = AsyncMock()\n    update.effective_user = MagicMock()\n    update.effective_user.id = 12345\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n    context.job_queue = MagicMock()\n    context.job_queue.run_once = MagicMock()  # Changed to MagicMock to avoid async warning\n    context.job_queue.get_jobs_by_name = MagicMock(return_value=[])\n\n    state = await keygenie_bot.buy_start(update, context)\n    assert state == keygenie_bot.SELECTING_PRODUCT\n    update.message.reply_text.assert_called_once()\n    args = update.message.reply_text.call_args[1]\n    assert isinstance(args['reply_markup'], InlineKeyboardMarkup)\n    assert \"üõí Please select a product\" in args['text']\n\n    # Test product selection with valid product\n    update.callback_query = MagicMock()\n    update.callback_query.data = \"SELECT_Category 1\"  # Use actual product from config\n    update.callback_query.from_user = MagicMock()\n    update.callback_query.from_user.id = 12345\n    update.callback_query.answer = AsyncMock()\n    update.callback_query.edit_message_text = AsyncMock()\n    update.callback_query.message = MagicMock()\n    update.callback_query.message.reply_text = AsyncMock()\n    context.user_data = {}\n\n    state = await keygenie_bot.product_selected(update, context)\n    assert state == keygenie_bot.WAITING_FOR_TXID\n    update.callback_query.answer.assert_called_once()\n    update.callback_query.edit_message_text.assert_called_once()\n\n    # Test cancel button\n    update.callback_query.data = \"CANCEL\"\n    state = await keygenie_bot.product_selected(update, context)\n    assert state == ConversationHandler.END\n\n    # Test back button - this should show products again\n    update.callback_query.data = \"BACK_TO_PRODUCTS\"\n    update.callback_query.edit_message_text.reset_mock()\n    state = await keygenie_bot.product_selected(update, context)\n    assert state == keygenie_bot.SELECTING_PRODUCT\n    update.callback_query.edit_message_text.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_timeout():\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n    context.bot = MagicMock()\n    context.bot.send_message = AsyncMock()\n    context.job = MagicMock()\n    context.job.data = 12345\n\n    await keygenie_bot.cancel_purchase_flow(context)\n    context.bot.send_message.assert_called_once()\n    args = context.bot.send_message.call_args[1]\n    assert \"timed out\" in args['text']\n\n@pytest.mark.asyncio\nasync def test_txid_handling():\n    # Test valid TXID submission\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.text = \"test_txid_123\"\n    update.message.reply_text = AsyncMock()\n    update.effective_user = MagicMock()\n    update.effective_user.id = 12345\n    update.effective_user.username = \"testuser\"\n    \n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n    context.bot = MagicMock()\n    context.bot.send_message = AsyncMock()\n    context.user_data = {'selected_product': 'Product A'}\n\n    state = await keygenie_bot.txid_received(update, context)\n    assert state == ConversationHandler.END\n    assert update.message.reply_text.call_count >= 1\n\n    # Test missing product\n    context.user_data = {}\n    state = await keygenie_bot.txid_received(update, context)\n    assert state == ConversationHandler.END\n    update.message.reply_text.assert_called_with(\n        \"‚ùå No product selected. Please use /buy to start the purchase flow.\"\n    )\n\n@pytest.mark.asyncio\nasync def test_error_handling():\n    # Test admin notification failure\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.text = \"test_txid_123\"\n    update.message.reply_text = AsyncMock()\n    update.effective_user = MagicMock()\n    update.effective_user.id = 12345\n    \n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n    context.bot = MagicMock()\n    context.bot.send_message = AsyncMock(side_effect=Exception(\"Test error\"))\n    context.user_data = {'selected_product': 'Product A'}\n\n    state = await keygenie_bot.txid_received(update, context)\n    assert state == ConversationHandler.END\n    # Should see error message to user\n    assert any(\"Failed to notify admin\" in call.args[0] \n              for call in update.message.reply_text.call_args_list)\n\n@pytest.mark.asyncio\nasync def test_random_message_handler():\n    update = MagicMock(spec=Update)\n    update.message = MagicMock()\n    update.message.reply_text = AsyncMock()\n    context = MagicMock(spec=ContextTypes.DEFAULT_TYPE)\n\n    await keygenie_bot.handle_random_message(update, context)\n    update.message.reply_text.assert_called_once()\n    args = update.message.reply_text.call_args[0][0]\n    assert any(response in args for response in keygenie_bot.HUMOROUS_RESPONSES)\n",
  "diff": "@@ -73,9 +73,9 @@\n     assert \"üõí Please select a product\" in args['text']\n \n     # Test product selection with valid product\n     update.callback_query = MagicMock()\n-    update.callback_query.data = \"SELECT_Product A\"\n+    update.callback_query.data = \"SELECT_Category 1\"  # Use actual product from config\n     update.callback_query.from_user = MagicMock()\n     update.callback_query.from_user.id = 12345\n     update.callback_query.answer = AsyncMock()\n     update.callback_query.edit_message_text = AsyncMock()\n",
  "description": "File modification",
  "taskId": "1749508150593",
  "revisionNumber": 1
}