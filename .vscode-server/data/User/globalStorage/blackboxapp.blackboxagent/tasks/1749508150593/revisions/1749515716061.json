{
  "id": "1749515716061",
  "timestamp": 1749515716061,
  "filePath": "keygenie_bot.py",
  "oldContent": "import logging\nfrom telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import (\n    ApplicationBuilder,\n    CommandHandler,\n    ContextTypes,\n    ConversationHandler,\n    MessageHandler,\n    CallbackQueryHandler,\n    filters,\n)\nimport config\n\n# Enable logging\nlogging.basicConfig(\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO\n)\nlogger = logging.getLogger(__name__)\n\n# States for ConversationHandler\nSELECTING_PRODUCT, WAITING_FOR_TXID = range(2)\n\n# Load configuration from config.py\nBOT_TOKEN = config.BOT_TOKEN\nADMIN_ID = config.ADMIN_ID\nBTC_ADDRESS = config.BTC_ADDRESS\nLTC_ADDRESS = config.LTC_ADDRESS\nUSDT_ADDRESS = config.USDT_ADDRESS\nPRODUCTS = config.PRODUCTS\n\nasync def verify_payment(txid: str, product: str) -> bool:\n    # Placeholder for automatic payment verification logic\n    # Currently, automatic verification is disabled; always return False\n    return False\n\n# Command handlers\n\n# Preset humorous responses for random messages\nHUMOROUS_RESPONSES = [\n    \"ðŸ˜„ I'm just a bot, but I love a good joke! Try /cmds to see what I can do.\",\n    \"ðŸ¤– Beep boop! I don't understand that, but I'm here to help with /buy and more.\",\n    \"ðŸ˜‚ That sounds funny! But let's stick to keys and payments. Use /cmds for commands.\",\n    \"ðŸ˜œ I'm not great at chit-chat, but I can help you buy keys! Try /buy.\",\n    \"ðŸ˜Ž Cool story! Now, how about some keys? Use /cmds to get started.\",\n]\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    logger.info(f\"User {update.effective_user.id} started the bot.\")\n    welcome_message = (\n        \"ðŸ‘¾ Welcome to *KeyGenie* Bot!\\n\"\n        \"Your gateway to secure key purchases.\\n\\n\"\n        \"Use /cmds to see available commands.\"\n    )\n    # Send image with welcome message to grab attention\n    image_path = \"robot_head.jpg\"\n    await update.message.reply_photo(photo=open(image_path, \"rb\"), caption=welcome_message)\n    # No need to delete image later, only show on /start\n\nasync def cmds(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    commands_text = (\n        \"ðŸ“œ *Available Commands:*\\n\"\n        \"/start â€” Welcome message\\n\"\n        \"/cmds â€” List commands\\n\"\n        \"/buy â€” Start purchase flow\\n\"\n        \"/info â€” User info (optional)\\n\"\n        \"/help â€” How to use the bot\\n\"\n        \"/terms â€” Terms and conditions\\n\"\n        \"/status â€” Check payment status\\n\"\n        \"/contact â€” Contact admin\"\n    )\n    await update.message.reply_markdown(commands_text)\n\nasync def handle_random_message(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    import random\n    response = random.choice(HUMOROUS_RESPONSES)\n    await update.message.reply_text(response)\n\nasync def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    help_text = (\n        \"ðŸ›’ *How to Use KeyGenie Bot:*\\n\"\n        \"1. Use /buy to start the purchase flow.\\n\"\n        \"2. Select a product from the catalog.\\n\"\n        \"3. View the price and payment addresses.\\n\"\n        \"4. Send your payment and then submit the transaction ID (TXID).\\n\"\n        \"5. An admin will verify your payment and send you the key.\\n\\n\"\n        \"Other commands:\\n\"\n        \"/start - Welcome message\\n\"\n        \"/cmds - List commands\\n\"\n        \"/info - Show your user info\\n\"\n        \"/help - Show this help message\\n\"\n        \"/terms - Show terms and conditions\\n\"\n        \"/status - Check payment status\\n\"\n        \"/contact - Contact admin\\n\"\n        \"/cancel - Cancel current operation\"\n    )\n    await update.message.reply_markdown(help_text)\n\nasync def terms(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    terms_text = (\n        \"ðŸ“œ *Terms and Conditions:*\\n\"\n        \"1. All sales are final.\\n\"\n        \"2. Payment verification is manual.\\n\"\n        \"3. Please ensure you send the correct amount.\\n\"\n        \"4. Contact admin for any issues.\"\n    )\n    await update.message.reply_markdown(terms_text)\n\nasync def info(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    user = update.effective_user\n    info_text = (\n        f\"ðŸ‘¤ *User Info:*\\n\"\n        f\"Username: @{user.username if user.username else 'N/A'}\\n\"\n        f\"User ID: {user.id}\\n\"\n        f\"First Name: {user.first_name}\\n\"\n        f\"Last Name: {user.last_name if user.last_name else 'N/A'}\"\n    )\n    await update.message.reply_markdown(info_text)\n\n# Purchase flow handlers\n\nasync def buy_start(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    logger.info(f\"User {update.effective_user.id} started /buy command.\")\n    product_names = list(PRODUCTS.keys())\n    keyboard = []\n    row = []\n    for i, name in enumerate(product_names):\n        row.append(InlineKeyboardButton(name, callback_data=name))\n        # Limit 2 buttons per row\n        if (i + 1) % 2 == 0:\n            keyboard.append(row)\n            row = []\n    if row:\n        keyboard.append(row)\n    # Add a cancel button row\n    keyboard.append([InlineKeyboardButton(\"â¬…ï¸ Back\", callback_data=\"BACK_TO_PRODUCTS\")])\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    await update.message.reply_text(\n        \"ðŸ›’ Please select a product to buy:\", reply_markup=reply_markup\n    )\n    # Start 30-minute timer to cancel purchase flow\n    context.job_queue.run_once(cancel_purchase_flow, 1800, data=update.effective_user.id, name=str(update.effective_user.id))\n    return SELECTING_PRODUCT\n\nasync def cancel_purchase_flow(context: ContextTypes.DEFAULT_TYPE):\n    user_id = context.job.data\n    try:\n        await context.bot.send_message(chat_id=user_id, text=\"â° Purchase flow timed out after 30 minutes. Please start again with /buy if you wish.\")\n    except Exception as e:\n        logger.error(f\"Failed to send timeout message to user {user_id}: {e}\")\n\nasync def product_selected(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer()\n    logger.info(f\"User {query.from_user.id} selected product: {query.data}\")\n    product = query.data\n\n    if product == \"BACK_TO_PRODUCTS\":\n        # Restart product selection\n        return await buy_start(update, context)\n\n    if product not in PRODUCTS:\n        await query.edit_message_text(\n            \"âŒ Invalid product selected. Please use /buy to start again.\"\n        )\n        return ConversationHandler.END\n\n    context.user_data['selected_product'] = product\n    price = PRODUCTS[product]['price']\n    payment_info = (\n        f\"ðŸ’° Price for {product}: {price}\\n\\n\"\n        f\"Please send payment to one of the following addresses:\\n\"\n        f\"BTC: {BTC_ADDRESS}\\n\"\n        f\"LTC: {LTC_ADDRESS}\\n\"\n        f\"USDT: {USDT_ADDRESS}\\n\\n\"\n        \"After payment, please send the transaction ID (TXID) here.\"\n    )\n    await query.edit_message_text(payment_info)\n    await query.message.reply_text(\"âš ï¸ Please make sure to double-check your payment details before sending the TXID.\")\n    return WAITING_FOR_TXID\n\nimport httpx\nimport json\nimport os\n\nUSER_DATA_FILE = \"user_data.json\"\n\ndef load_user_data():\n    if not os.path.exists(USER_DATA_FILE):\n        return {}\n    with open(USER_DATA_FILE, \"r\") as f:\n        return json.load(f)\n\ndef save_user_data(data):\n    with open(USER_DATA_FILE, \"w\") as f:\n        json.dump(data, f, indent=2)\n\nasync def deliver_key(user_id: int, product: str, context: ContextTypes.DEFAULT_TYPE):\n    user_data = load_user_data()\n    user_record = user_data.get(str(user_id), {\"purchases\": []})\n    product_key = config.PRODUCTS[product][\"key\"]\n\n    # Send the product key to the user\n    try:\n        await context.bot.send_message(\n            chat_id=user_id,\n            text=f\"ðŸŽ‰ Your purchase of *{product}* is confirmed!\\nHere is your product key:\\n`{product_key}`\",\n            parse_mode=\"Markdown\",\n        )\n        logger.info(f\"Delivered key for {product} to user {user_id}\")\n    except Exception as e:\n        logger.error(f\"Failed to deliver key to user {user_id}: {e}\")\n        return False\n\n    # Update user purchase history\n    user_record[\"purchases\"].append({\"product\": product, \"key\": product_key})\n    user_data[str(user_id)] = user_record\n    save_user_data(user_data)\n    return True\n\nasync def txid_received(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    txid = update.message.text.strip()\n    product = context.user_data.get('selected_product')\n\n    if not product:\n        await update.message.reply_text(\n            \"âŒ No product selected. Please use /buy to start the purchase flow.\"\n        )\n        return ConversationHandler.END\n\n    user = update.effective_user\n\n    if config.AUTO_VERIFICATION_ENABLED:\n        verified = await verify_payment(txid, product)\n        if verified:\n            delivered = await deliver_key(user.id, product, context)\n            if delivered:\n                await update.message.reply_text(\n                    f\"âœ… Payment verified automatically! Your key for {product} has been sent.\"\n                )\n            else:\n                await update.message.reply_text(\n                    \"âš ï¸ Payment verified but failed to deliver the product key. Please contact admin.\"\n                )\n            logger.info(f\"Auto verified payment for user {user.id}, product {product}, txid {txid}\")\n            return ConversationHandler.END\n        else:\n            await update.message.reply_text(\n                \"âš ï¸ Payment could not be verified automatically. It will be reviewed manually.\"\n            )\n\n    # Manual verification fallback\n    admin_message = (\n        f\"ðŸ“¢ Payment TXID received from user @{user.username if user.username else user.id}:\\n\"\n        f\"Product: {product}\\n\"\n        f\"TXID: {txid}\\n\\n\"\n        \"Please verify the payment and send the key to the user.\"\n    )\n    try:\n        await context.bot.send_message(chat_id=ADMIN_ID, text=admin_message, parse_mode=\"MarkdownV2\")\n        logger.info(f\"Notified admin {ADMIN_ID} of payment TXID from user {user.id}\")\n    except Exception as e:\n        logger.error(f\"Failed to notify admin: {e}\")\n        await update.message.reply_text(\n            \"âš ï¸ Failed to notify admin. Please contact support or try again later.\"\n        )\n        return ConversationHandler.END\n\n    await update.message.reply_text(\n        \"âœ… Thank you! Your payment TXID has been received and is pending verification by the admin.\"\n    )\n    await update.message.reply_text(\"â„¹ï¸ If you have any questions, use /help or contact the admin.\")\n    return ConversationHandler.END\n\nasync def status(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    # Placeholder for payment status checking logic\n    await update.message.reply_text(\n        \"ðŸ” Payment status feature is coming soon. Please check back later.\"\n    )\n\nasync def contact(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    contact_info = (\n        \"ðŸ“ž *Contact Admin:*\\n\"\n        \"For support or inquiries, please contact @YourAdminUsername.\"\n    )\n    await update.message.reply_markdown(contact_info)\n\nasync def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    await update.message.reply_text(\n        \"âŒ Purchase flow cancelled.\", reply_markup=ReplyKeyboardRemove()\n    )\n    return ConversationHandler.END\n\ndef main():\n    application = ApplicationBuilder().token(BOT_TOKEN).build()\n    logger.info(\"Starting bot...\")\n\n    conv_handler = ConversationHandler(\n        entry_points=[CommandHandler('buy', buy_start)],\n        states={\n            SELECTING_PRODUCT: [CallbackQueryHandler(product_selected)],\n            WAITING_FOR_TXID: [MessageHandler(filters.TEXT & ~filters.COMMAND, txid_received)],\n        },\n        fallbacks=[CommandHandler('cancel', cancel)],\n        per_message=False\n    )\n\n    # Add handlers in specific order\n    application.add_handler(CommandHandler('start', start))\n    application.add_handler(CommandHandler('cmds', cmds))\n    application.add_handler(CommandHandler('help', help_command))\n    application.add_handler(CommandHandler('terms', terms))\n    application.add_handler(CommandHandler('info', info))\n    application.add_handler(CommandHandler('status', status))\n    application.add_handler(CommandHandler('contact', contact))\n    application.add_handler(conv_handler)\n\n    # Add handler for random messages to reply with humor\n    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_random_message))\n\n    logger.info(\"Bot handlers registered, starting polling...\")\n    application.run_polling()\n\nif __name__ == '__main__':\n    main()\n",
  "content": "import logging\nfrom telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import (\n    ApplicationBuilder,\n    CommandHandler,\n    ContextTypes,\n    ConversationHandler,\n    MessageHandler,\n    CallbackQueryHandler,\n    filters,\n)\nimport config\n\n# Enable logging\nlogging.basicConfig(\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO\n)\nlogger = logging.getLogger(__name__)\n\n# States for ConversationHandler\nSELECTING_PRODUCT, WAITING_FOR_TXID = range(2)\n\n# Timer job names\nTIMEOUT_JOB_NAME = \"purchase_timeout_{}\"\n\n# Load configuration from config.py\nBOT_TOKEN = config.BOT_TOKEN\nADMIN_ID = config.ADMIN_ID\nBTC_ADDRESS = config.BTC_ADDRESS\nLTC_ADDRESS = config.LTC_ADDRESS\nUSDT_ADDRESS = config.USDT_ADDRESS\nPRODUCTS = config.PRODUCTS\n\ndef clear_purchase_timeout(context: ContextTypes.DEFAULT_TYPE, user_id: int):\n    \"\"\"Clear the purchase timeout job for a user\"\"\"\n    current_jobs = context.job_queue.get_jobs_by_name(TIMEOUT_JOB_NAME.format(user_id))\n    for job in current_jobs:\n        job.schedule_removal()\n\nasync def verify_payment(txid: str, product: str) -> bool:\n    # Placeholder for automatic payment verification logic\n    # Currently, automatic verification is disabled; always return False\n    return False\n\n# Command handlers\n\n# Preset humorous responses for random messages\nHUMOROUS_RESPONSES = [\n    \"ðŸ˜„ I'm just a bot, but I love a good joke! Try /cmds to see what I can do.\",\n    \"ðŸ¤– Beep boop! I don't understand that, but I'm here to help with /buy and more.\",\n    \"ðŸ˜‚ That sounds funny! But let's stick to keys and payments. Use /cmds for commands.\",\n    \"ðŸ˜œ I'm not great at chit-chat, but I can help you buy keys! Try /buy.\",\n    \"ðŸ˜Ž Cool story! Now, how about some keys? Use /cmds to get started.\",\n]\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    logger.info(f\"User {update.effective_user.id} started the bot.\")\n    welcome_message = (\n        \"ðŸ‘¾ Welcome to *KeyGenie* Bot!\\n\"\n        \"Your gateway to secure key purchases.\\n\\n\"\n        \"Use /cmds to see available commands.\"\n    )\n    # Send image with welcome message to grab attention\n    image_path = \"robot_head.jpg\"\n    await update.message.reply_photo(photo=open(image_path, \"rb\"), caption=welcome_message)\n    # No need to delete image later, only show on /start\n\nasync def cmds(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    commands_text = (\n        \"ðŸ“œ *Available Commands:*\\n\"\n        \"/start â€” Welcome message\\n\"\n        \"/cmds â€” List commands\\n\"\n        \"/buy â€” Start purchase flow\\n\"\n        \"/info â€” User info (optional)\\n\"\n        \"/help â€” How to use the bot\\n\"\n        \"/terms â€” Terms and conditions\\n\"\n        \"/status â€” Check payment status\\n\"\n        \"/contact â€” Contact admin\"\n    )\n    await update.message.reply_markdown(commands_text)\n\nasync def handle_random_message(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    import random\n    response = random.choice(HUMOROUS_RESPONSES)\n    await update.message.reply_text(response)\n\nasync def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    help_text = (\n        \"ðŸ›’ *How to Use KeyGenie Bot:*\\n\"\n        \"1. Use /buy to start the purchase flow.\\n\"\n        \"2. Select a product from the catalog.\\n\"\n        \"3. View the price and payment addresses.\\n\"\n        \"4. Send your payment and then submit the transaction ID (TXID).\\n\"\n        \"5. An admin will verify your payment and send you the key.\\n\\n\"\n        \"Other commands:\\n\"\n        \"/start - Welcome message\\n\"\n        \"/cmds - List commands\\n\"\n        \"/info - Show your user info\\n\"\n        \"/help - Show this help message\\n\"\n        \"/terms - Show terms and conditions\\n\"\n        \"/status - Check payment status\\n\"\n        \"/contact - Contact admin\\n\"\n        \"/cancel - Cancel current operation\"\n    )\n    await update.message.reply_markdown(help_text)\n\nasync def terms(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    terms_text = (\n        \"ðŸ“œ *Terms and Conditions:*\\n\"\n        \"1. All sales are final.\\n\"\n        \"2. Payment verification is manual.\\n\"\n        \"3. Please ensure you send the correct amount.\\n\"\n        \"4. Contact admin for any issues.\"\n    )\n    await update.message.reply_markdown(terms_text)\n\nasync def info(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    user = update.effective_user\n    info_text = (\n        f\"ðŸ‘¤ *User Info:*\\n\"\n        f\"Username: @{user.username if user.username else 'N/A'}\\n\"\n        f\"User ID: {user.id}\\n\"\n        f\"First Name: {user.first_name}\\n\"\n        f\"Last Name: {user.last_name if user.last_name else 'N/A'}\"\n    )\n    await update.message.reply_markdown(info_text)\n\n# Purchase flow handlers\n\nasync def buy_start(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    logger.info(f\"User {update.effective_user.id} started /buy command.\")\n    product_names = list(PRODUCTS.keys())\n    keyboard = []\n    row = []\n    for i, name in enumerate(product_names):\n        row.append(InlineKeyboardButton(name, callback_data=name))\n        # Limit 2 buttons per row\n        if (i + 1) % 2 == 0:\n            keyboard.append(row)\n            row = []\n    if row:\n        keyboard.append(row)\n    # Add a cancel button row\n    keyboard.append([InlineKeyboardButton(\"â¬…ï¸ Back\", callback_data=\"BACK_TO_PRODUCTS\")])\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    await update.message.reply_text(\n        \"ðŸ›’ Please select a product to buy:\", reply_markup=reply_markup\n    )\n    # Start 30-minute timer to cancel purchase flow\n    context.job_queue.run_once(cancel_purchase_flow, 1800, data=update.effective_user.id, name=str(update.effective_user.id))\n    return SELECTING_PRODUCT\n\nasync def cancel_purchase_flow(context: ContextTypes.DEFAULT_TYPE):\n    user_id = context.job.data\n    try:\n        await context.bot.send_message(chat_id=user_id, text=\"â° Purchase flow timed out after 30 minutes. Please start again with /buy if you wish.\")\n    except Exception as e:\n        logger.error(f\"Failed to send timeout message to user {user_id}: {e}\")\n\nasync def product_selected(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.callback_query\n    await query.answer()\n    logger.info(f\"User {query.from_user.id} selected product: {query.data}\")\n    product = query.data\n\n    if product == \"BACK_TO_PRODUCTS\":\n        # Restart product selection\n        return await buy_start(update, context)\n\n    if product not in PRODUCTS:\n        await query.edit_message_text(\n            \"âŒ Invalid product selected. Please use /buy to start again.\"\n        )\n        return ConversationHandler.END\n\n    context.user_data['selected_product'] = product\n    price = PRODUCTS[product]['price']\n    payment_info = (\n        f\"ðŸ’° Price for {product}: {price}\\n\\n\"\n        f\"Please send payment to one of the following addresses:\\n\"\n        f\"BTC: {BTC_ADDRESS}\\n\"\n        f\"LTC: {LTC_ADDRESS}\\n\"\n        f\"USDT: {USDT_ADDRESS}\\n\\n\"\n        \"After payment, please send the transaction ID (TXID) here.\"\n    )\n    await query.edit_message_text(payment_info)\n    await query.message.reply_text(\"âš ï¸ Please make sure to double-check your payment details before sending the TXID.\")\n    return WAITING_FOR_TXID\n\nimport httpx\nimport json\nimport os\n\nUSER_DATA_FILE = \"user_data.json\"\n\ndef load_user_data():\n    if not os.path.exists(USER_DATA_FILE):\n        return {}\n    with open(USER_DATA_FILE, \"r\") as f:\n        return json.load(f)\n\ndef save_user_data(data):\n    with open(USER_DATA_FILE, \"w\") as f:\n        json.dump(data, f, indent=2)\n\nasync def deliver_key(user_id: int, product: str, context: ContextTypes.DEFAULT_TYPE):\n    user_data = load_user_data()\n    user_record = user_data.get(str(user_id), {\"purchases\": []})\n    product_key = config.PRODUCTS[product][\"key\"]\n\n    # Send the product key to the user\n    try:\n        await context.bot.send_message(\n            chat_id=user_id,\n            text=f\"ðŸŽ‰ Your purchase of *{product}* is confirmed!\\nHere is your product key:\\n`{product_key}`\",\n            parse_mode=\"Markdown\",\n        )\n        logger.info(f\"Delivered key for {product} to user {user_id}\")\n    except Exception as e:\n        logger.error(f\"Failed to deliver key to user {user_id}: {e}\")\n        return False\n\n    # Update user purchase history\n    user_record[\"purchases\"].append({\"product\": product, \"key\": product_key})\n    user_data[str(user_id)] = user_record\n    save_user_data(user_data)\n    return True\n\nasync def txid_received(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    txid = update.message.text.strip()\n    product = context.user_data.get('selected_product')\n\n    if not product:\n        await update.message.reply_text(\n            \"âŒ No product selected. Please use /buy to start the purchase flow.\"\n        )\n        return ConversationHandler.END\n\n    user = update.effective_user\n\n    if config.AUTO_VERIFICATION_ENABLED:\n        verified = await verify_payment(txid, product)\n        if verified:\n            delivered = await deliver_key(user.id, product, context)\n            if delivered:\n                await update.message.reply_text(\n                    f\"âœ… Payment verified automatically! Your key for {product} has been sent.\"\n                )\n            else:\n                await update.message.reply_text(\n                    \"âš ï¸ Payment verified but failed to deliver the product key. Please contact admin.\"\n                )\n            logger.info(f\"Auto verified payment for user {user.id}, product {product}, txid {txid}\")\n            return ConversationHandler.END\n        else:\n            await update.message.reply_text(\n                \"âš ï¸ Payment could not be verified automatically. It will be reviewed manually.\"\n            )\n\n    # Manual verification fallback\n    admin_message = (\n        f\"ðŸ“¢ Payment TXID received from user @{user.username if user.username else user.id}:\\n\"\n        f\"Product: {product}\\n\"\n        f\"TXID: {txid}\\n\\n\"\n        \"Please verify the payment and send the key to the user.\"\n    )\n    try:\n        await context.bot.send_message(chat_id=ADMIN_ID, text=admin_message, parse_mode=\"MarkdownV2\")\n        logger.info(f\"Notified admin {ADMIN_ID} of payment TXID from user {user.id}\")\n    except Exception as e:\n        logger.error(f\"Failed to notify admin: {e}\")\n        await update.message.reply_text(\n            \"âš ï¸ Failed to notify admin. Please contact support or try again later.\"\n        )\n        return ConversationHandler.END\n\n    await update.message.reply_text(\n        \"âœ… Thank you! Your payment TXID has been received and is pending verification by the admin.\"\n    )\n    await update.message.reply_text(\"â„¹ï¸ If you have any questions, use /help or contact the admin.\")\n    return ConversationHandler.END\n\nasync def status(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    # Placeholder for payment status checking logic\n    await update.message.reply_text(\n        \"ðŸ” Payment status feature is coming soon. Please check back later.\"\n    )\n\nasync def contact(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    contact_info = (\n        \"ðŸ“ž *Contact Admin:*\\n\"\n        \"For support or inquiries, please contact @YourAdminUsername.\"\n    )\n    await update.message.reply_markdown(contact_info)\n\nasync def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    await update.message.reply_text(\n        \"âŒ Purchase flow cancelled.\", reply_markup=ReplyKeyboardRemove()\n    )\n    return ConversationHandler.END\n\ndef main():\n    application = ApplicationBuilder().token(BOT_TOKEN).build()\n    logger.info(\"Starting bot...\")\n\n    conv_handler = ConversationHandler(\n        entry_points=[CommandHandler('buy', buy_start)],\n        states={\n            SELECTING_PRODUCT: [CallbackQueryHandler(product_selected)],\n            WAITING_FOR_TXID: [MessageHandler(filters.TEXT & ~filters.COMMAND, txid_received)],\n        },\n        fallbacks=[CommandHandler('cancel', cancel)],\n        per_message=False\n    )\n\n    # Add handlers in specific order\n    application.add_handler(CommandHandler('start', start))\n    application.add_handler(CommandHandler('cmds', cmds))\n    application.add_handler(CommandHandler('help', help_command))\n    application.add_handler(CommandHandler('terms', terms))\n    application.add_handler(CommandHandler('info', info))\n    application.add_handler(CommandHandler('status', status))\n    application.add_handler(CommandHandler('contact', contact))\n    application.add_handler(conv_handler)\n\n    # Add handler for random messages to reply with humor\n    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_random_message))\n\n    logger.info(\"Bot handlers registered, starting polling...\")\n    application.run_polling()\n\nif __name__ == '__main__':\n    main()\n",
  "diff": "@@ -19,16 +19,25 @@\n \n # States for ConversationHandler\n SELECTING_PRODUCT, WAITING_FOR_TXID = range(2)\n \n+# Timer job names\n+TIMEOUT_JOB_NAME = \"purchase_timeout_{}\"\n+\n # Load configuration from config.py\n BOT_TOKEN = config.BOT_TOKEN\n ADMIN_ID = config.ADMIN_ID\n BTC_ADDRESS = config.BTC_ADDRESS\n LTC_ADDRESS = config.LTC_ADDRESS\n USDT_ADDRESS = config.USDT_ADDRESS\n PRODUCTS = config.PRODUCTS\n \n+def clear_purchase_timeout(context: ContextTypes.DEFAULT_TYPE, user_id: int):\n+    \"\"\"Clear the purchase timeout job for a user\"\"\"\n+    current_jobs = context.job_queue.get_jobs_by_name(TIMEOUT_JOB_NAME.format(user_id))\n+    for job in current_jobs:\n+        job.schedule_removal()\n+\n async def verify_payment(txid: str, product: str) -> bool:\n     # Placeholder for automatic payment verification logic\n     # Currently, automatic verification is disabled; always return False\n     return False\n",
  "description": "File modification",
  "taskId": "1749508150593",
  "revisionNumber": 1
}